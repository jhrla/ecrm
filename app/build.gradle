plugins {
    id 'org.springframework.boot' version '3.2.8'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'war'
    id 'com.github.node-gradle.node' version '3.0.1'
}

group = 'com.ktss'
version = '0.0.1-SNAPSHOT'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

bootRun {
    main = 'com.ktss.KtssApplication'
}

repositories {
	mavenCentral()
}

dependencies {
    implementation 'com.google.firebase:firebase-admin:9.4.3'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.3'
    implementation 'org.mybatis:mybatis:3.5.13'       
    implementation 'com.zaxxer:HikariCP:5.0.1'
    implementation 'com.google.code.gson:gson:2.10' 
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client:3.4.1' 
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation 'org.apache.poi:poi-ooxml:5.2.3'
    // implementation 'org.bytedeco:javacv-platform:1.5.9'
    // implementation 'org.bytedeco:ffmpeg-platform:6.0-1.5.9'
    // implementation 'com.fasterxml.jackson.core:jackson-databind'
}
 
springBoot {
    mainClass.set('com.ktss.safety.SafetyApplication')
}

bootWar {
    enabled = false    
}

// ... 기존 코드 유지 ...

processResources {
    // 기존 파일 삭제 옵션 추가
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    
    // local 설정 파일 제외
    exclude('**/application-local.properties')
    
    // application-prod.properties를 application.properties로 복사
    filesMatching('**/application-prod.properties') {
        rename { String fileName ->
            fileName.replace('application-prod.properties', 'application.properties')
        }
    }
}

war {
    // 기존 war task 설정은 유지하면서 리소스 처리 설정만 추가
    exclude('**/application-local.properties')

    archiveClassifier = ''
    archiveFileName = "${rootProject.name}-${version}.war" // 프로젝트 이름과 버전 포함
    // React 빌드 결과물을 WEB-INF/classes/static에만 포함
    from("$buildDir/resources/main/static") {
        into 'WEB-INF/classes/static'
    }

    // 루트 경로에 React 빌드 파일이 복사되지 않도록 설정
    exclude('**/build/**', '**/frontend/**')

    // 중복 파일 처리 전략
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    destinationDirectory.set(file("$rootDir/build/libs"))
}

node {
    workDir = file("${project.buildDir}/nodejs")
    npmWorkDir = file("${project.buildDir}/npm")
    nodeModulesDir = file("$projectDir/frontend")
}

// React 프로젝트 폴더 경로 설정
def frontendDir = "$rootDir/frontend"

task installReactDeps(type: NpmTask) {
    workingDir = file(frontendDir)
    args = ['install']
}

task buildReactDev(type: NpmTask) {
    dependsOn installReactDeps
    workingDir = file(frontendDir)
    args = ['run', 'build:dev']
}

task buildReactProd(type: NpmTask) {
    dependsOn installReactDeps
    
    // 루트 프로젝트의 frontend 폴더 지정
    workingDir = file("${rootProject.projectDir}/frontend")
    
    // npm run build:prod 실행
    args = ['run', 'build:prod']
    
    doFirst {
        println "=== Starting React production build ==="
        println "Working directory: ${workingDir}"
    }
    
    doLast {
        println "=== React production build completed ==="
    }
}

task copyReactDevBuildToResources(type: Copy) {
    dependsOn buildReactDev
    from("$frontendDir/build") {
        include '**/*'
    }
    into "$buildDir/resources/main/static"
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

task copyReactProdBuildToResources(type: Copy) {
    dependsOn buildReactProd
    from("$frontendDir/build") {
        include '**/*'
    }
    into "$buildDir/resources/main/static"
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Spring Boot 리소스 처리 전에 React 빌드를 실행
tasks.named('processResources') {
    doFirst {
        // buildProd 태스크가 실행될 때는 무조건 prod 프로필 사용
        if (gradle.startParameter.taskNames.contains('buildProd')) {
            project.ext.profile = 'prod'
            println "Using production build (forced by buildProd task)"
        } else {
            println "Current profile: ${project.findProperty('profile') ?: 'dev'}"
        }
    }
    
    // buildProd 태스크가 실행될 때는 무조건 prod 빌드 실행
    if (gradle.startParameter.taskNames.contains('buildProd') || 
        (project.hasProperty('profile') && project.property('profile') == 'prod')) {
        println "Using production build"
        dependsOn 'copyReactProdBuildToResources'
        // dev 빌드 비활성화
        project.tasks.findByName('buildReactDev')?.enabled = false
    } else {
        println "Using development build"
        dependsOn 'copyReactDevBuildToResources'
        // prod 빌드 비활성화
        project.tasks.findByName('buildReactProd')?.enabled = false
    }
}

// 컴파일된 클래스 파일을 build/classes 디렉토리에 복사하는 작업 추가
task copyCompiledClasses(type: Copy) {
    from sourceSets.main.output
    into "$rootDir/build/classes"
}

// 소스 코드 파일을 build/sources 디렉토리에 복사하는 작업 추가
task copySources(type: Copy) {
    from sourceSets.main.allSource
    into "$rootDir/build/sources"
}

// React 빌드 결과를 build/react 디렉토리에 복사하는 작업 추가
task copyReactBuildToBuildFolder(type: Copy) {
    dependsOn buildReactDev
    from("$frontendDir/build")
    into "$rootDir/build/react"
}

task copyWarToDockerContainer(type: Exec) {
    // Docker 컨테이너 이름과 WAR 파일의 경로를 지
    def warFile = "$rootDir/build/libs/${rootProject.name}-${version}.war"
    def containerName = "oztomcat"
    def destinationPath = "/usr/local/tomcat/webapps/ROOT.war"

    // 실제 실행할 명령어
    commandLine "docker", "cp", warFile, "${containerName}:${destinationPath}"

    // 태스크 완료 후 메시지 출력
    doLast {
        println "WAR file copied to ${containerName}:${destinationPath}"
    }
}

// 개발 환경 전체 빌드
task buildDev {
    dependsOn clean, buildReactDev, copyReactDevBuildToResources, war
    doLast {
        println "Development build completed"
    }
}

// 전체 빌드 작업 정의
task buildAll {
    dependsOn buildDev  // 기본적으로 개발 환경으로 빌드
}

// 전체 빌드 후, 컴파일된 클래스, 소스 파일, 그리고 React 빌드 파일 복사
build.finalizedBy(copyCompiledClasses, copySources, copyReactBuildToBuildFolder)

tasks.named('war') {
    dependsOn 'copyReactProdBuildToResources'
}

tasks.register('buildProd') {
    group = 'build'
    description = 'Builds the production application'

    doFirst {
        println "=== Starting Production Build ==="
        project.ext.profile = 'prod'
        println "Profile set to: prod"
    }

    dependsOn(
        'clean',
        'installReactDeps',
        'buildReactProd',
        'processResources',
        'war'
    )

    doLast {
        println "=== Production Build Completed ==="
        println "WAR file location: ${war.archiveFile.get().asFile}"
    }
}

// NpmTask 설정
tasks.withType(com.github.gradle.node.npm.task.NpmTask) {
    if (name == 'buildReactProd') {
        dependsOn 'installReactDeps'
    }
}

// 나머지 태스크 의존성 설정
tasks.named('copyReactProdBuildToResources') {
    dependsOn 'buildReactProd'
}

tasks.named('war') {
    dependsOn 'copyReactProdBuildToResources'
}

// 각 태스크에 로깅 추가
tasks.withType(com.github.gradle.node.npm.task.NpmTask) {
    doFirst {
        println "=== Executing ${name} ==="
    }
    doLast {
        println "=== Completed ${name} ==="
    }
}

// war 태스크에 프로파일 설정 추가
tasks.named('war') {
    doFirst {
        manifest {
            attributes(
                'Spring-Profile': 'prod'
            )
        }
    }
}

// war 태스크가 buildReactProd 이후에 실행되도록 설정
war.dependsOn buildReactProd